{"ast":null,"code":"var _jsxFileName = \"/Users/jimmyzhou/Desktop/Projects/scripty/frontend/src/pages/mindmap.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useCallback, useEffect, useMemo } from 'react';\nimport MindMapCanvas from '../components/mindmapcanvas';\nimport MindMapToolbar from '../components/mindmaptoolbar';\nimport MindMapInstructions from '../components/mindmapinstructions';\nimport LargeTextEditor from '../components/mindmaptexteditor';\n// REMOVE THIS LINE: import Auth from '../pages/auth'; // <--- REMOVED IMPORT\nimport './mindmap.css';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_BASE_URL = process.env.REACT_APP_BACKEND_API_URL || 'http://localhost:5001/api';\nconst MindMap = () => {\n  _s();\n  var _nodes$find, _session$user;\n  const {\n    id\n  } = useParams();\n  const navigate = useNavigate();\n  const [nodes, setNodes] = useState([{\n    id: '1',\n    x: 400,\n    y: 300,\n    title: 'Central Idea',\n    text: '',\n    isRoot: true,\n    color: '#dc2626'\n  }]);\n  const [connections, setConnections] = useState([]);\n  const [draggedNode, setDraggedNode] = useState(null);\n  const [selectedNode, setSelectedNode] = useState(null);\n  const [isLargeEditorOpen, setIsLargeEditorOpen] = useState(false);\n  const [largeEditorNodeId, setLargeEditorNodeId] = useState(null);\n  const [largeEditorTitle, setLargeEditorTitle] = useState('');\n  const [largeEditorText, setLargeEditorText] = useState('');\n  const [translateX, setTranslateX] = useState(0);\n  const [translateY, setTranslateY] = useState(0);\n  const [isPanning, setIsPanning] = useState(false);\n  const panStartRef = useRef({\n    x: 0,\n    y: 0,\n    startTranslateX: 0,\n    startTranslateY: 0\n  });\n  const svgRef = useRef(null);\n  const containerRef = useRef(null);\n  const canvasWrapperRef = useRef(null);\n  const dragDataRef = useRef({\n    isDragging: false,\n    offset: {\n      x: 0,\n      y: 0\n    }\n  });\n  const animationFrameRef = useRef(null);\n  const colors = useMemo(() => ['#EF4444', '#F97316', '#EAB308', '#22C55E', '#3B82F6', '#A855F7', '#EC4899'], []);\n\n  // --- State for Backend Integration ---\n  const [session, setSession] = useState(null);\n  const [currentMindMapId, setCurrentMindMapId] = useState(null);\n  const [currentMapTitle, setCurrentMapTitle] = useState('Untitled Map');\n  const [userMindMaps, setUserMindMaps] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [message, setMessage] = useState('Welcome! Login or register to start creating.');\n\n  // --- Authentication & Session Management ---\n  // Note: The onAuthSuccess callback is no longer needed here as Auth handles navigation\n  // The session check in this useEffect will now redirect if there's no valid session,\n  // relying on ProtectedRoute to guard the path.\n  useEffect(() => {\n    const storedSession = localStorage.getItem('mindmapSession');\n    if (storedSession) {\n      try {\n        const parsedSession = JSON.parse(storedSession);\n        if (parsedSession && parsedSession.token && parsedSession.user) {\n          setSession(parsedSession);\n          setMessage(`Welcome back, ${parsedSession.user.email}!`);\n          fetchUserMindMaps(parsedSession.token);\n        } else {\n          localStorage.removeItem('mindmapSession'); // Clear invalid session\n          navigate('/'); // Redirect to login if session invalid\n        }\n      } catch (e) {\n        console.error(\"Failed to parse session from localStorage\", e);\n        localStorage.removeItem('mindmapSession');\n        navigate('/'); // Redirect to login if session parsing fails\n      }\n    } else {\n      navigate('/'); // Redirect to login if no session at all\n    }\n    // Added fetchUserMindMaps to dependency array for completeness and correctness\n  }, [navigate, fetchUserMindMaps]);\n  useEffect(() => {\n    if (!session) return; // Wait for session to be established\n    if (id && id !== 'new') {\n      loadMindMapFromServer(id);\n    } else if (id === 'new') {\n      handleNewMap();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [session, id]); // Depend on session and id to trigger loading\n\n  const handleAuthSuccess = useCallback(() => {\n    // This callback is now effectively managed by the Auth component itself\n    // and is primarily for MindMap to react to a successful login if it's already rendered\n    // (though with ProtectedRoute, it won't be rendered unless logged in).\n    // The previous logic for calling fetchUserMindMaps is now handled in the useEffect above.\n  }, []); // No dependencies needed as it's not directly used for navigation anymore\n\n  const handleLogout = useCallback(() => {\n    setSession(null);\n    localStorage.removeItem('mindmapSession');\n    // Clear current map data and reset to a new default map\n    setNodes([{\n      id: '1',\n      x: 400,\n      y: 300,\n      title: 'Central Idea',\n      text: '',\n      isRoot: true,\n      color: '#dc2626'\n    }]);\n    setConnections([]);\n    setTranslateX(0);\n    setTranslateY(0);\n    setCurrentMindMapId(null);\n    setCurrentMapTitle('Untitled Map');\n    setUserMindMaps([]); // Clear user maps on logout\n    setMessage('You have been logged out.');\n    navigate('/'); // Redirect to login page after logout\n  }, [navigate]); // Added navigate to dependency array\n\n  // --- API Calls (no changes needed here) ---\n\n  const fetchUserMindMaps = useCallback(async token => {\n    setLoading(true);\n    setMessage('Fetching your mind maps...');\n    try {\n      const response = await fetch(`${API_BASE_URL}/mindmaps`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      if (!response.ok) {\n        if (response.status === 401) {\n          setMessage('Session expired or unauthorized. Please log in again.');\n          handleLogout(); // Log out if unauthorized\n          return;\n        }\n        throw new Error(`Error fetching mind maps: ${response.statusText}`);\n      }\n      const data = await response.json();\n      setUserMindMaps(data);\n      setMessage('Your mind maps loaded!');\n    } catch (error) {\n      console.error('Fetch mind maps error:', error);\n      setMessage(`Failed to fetch mind maps: ${error.message}`);\n    } finally {\n      setLoading(false);\n    }\n  }, [handleLogout]);\n  const saveMindMapToServer = useCallback(async () => {\n    if (!session || !session.token) {\n      setMessage('Please log in to save your mind map.');\n      return;\n    }\n    setLoading(true);\n    setMessage('Saving mind map...');\n    try {\n      const mindMapData = {\n        title: currentMapTitle,\n        nodes,\n        connections,\n        viewState: {\n          translateX,\n          translateY\n        }\n      };\n      let response;\n      if (currentMindMapId) {\n        // Update existing mind map\n        response = await fetch(`${API_BASE_URL}/mindmaps/${currentMindMapId}`, {\n          method: 'PUT',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${session.token}`\n          },\n          body: JSON.stringify(mindMapData)\n        });\n      } else {\n        // Create new mind map\n        response = await fetch(`${API_BASE_URL}/mindmaps`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${session.token}`\n          },\n          body: JSON.stringify(mindMapData)\n        });\n      }\n      if (!response.ok) {\n        if (response.status === 401) {\n          setMessage('Session expired or unauthorized. Please log in again to save.');\n          handleLogout();\n          return;\n        }\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Failed to save mind map');\n      }\n      const savedMap = await response.json();\n      setCurrentMindMapId(savedMap._id);\n      setCurrentMapTitle(savedMap.title);\n      setMessage('Mind map saved successfully!');\n      fetchUserMindMaps(session.token); // Refresh the list of maps\n    } catch (error) {\n      console.error('Save mind map error:', error);\n      setMessage(`Error saving mind map: ${error.message}`);\n    } finally {\n      setLoading(false);\n    }\n  }, [nodes, connections, translateX, translateY, currentMindMapId, currentMapTitle, session, fetchUserMindMaps, handleLogout]);\n  const loadMindMapFromServer = useCallback(async mapId => {\n    if (!session || !session.token) {\n      setMessage('Please log in to load a mind map.');\n      return;\n    }\n    setLoading(true);\n    setMessage('Loading mind map...');\n    try {\n      var _data$viewState, _data$viewState2;\n      const response = await fetch(`${API_BASE_URL}/mindmaps/${mapId}`, {\n        headers: {\n          'Authorization': `Bearer ${session.token}`\n        }\n      });\n      if (!response.ok) {\n        if (response.status === 401) {\n          setMessage('Session expired or unauthorized. Please log in again.');\n          handleLogout();\n          return;\n        }\n        throw new Error(`Error loading mind map: ${response.statusText}`);\n      }\n      const data = await response.json();\n      setNodes(data.nodes || []);\n      setConnections(data.connections || []);\n      setTranslateX(((_data$viewState = data.viewState) === null || _data$viewState === void 0 ? void 0 : _data$viewState.translateX) || 0);\n      setTranslateY(((_data$viewState2 = data.viewState) === null || _data$viewState2 === void 0 ? void 0 : _data$viewState2.translateY) || 0);\n      setCurrentMindMapId(data._id);\n      setCurrentMapTitle(data.title);\n      setMessage(`Mind map \"${data.title}\" loaded!`);\n    } catch (error) {\n      console.error('Load mind map error:', error);\n      setMessage(`Failed to load mind map: ${error.message}`);\n    } finally {\n      setLoading(false);\n    }\n  }, [session, handleLogout]);\n  const handleNewMap = useCallback(() => {\n    setNodes([{\n      id: '1',\n      x: 400,\n      y: 300,\n      title: 'Central Idea',\n      text: '',\n      isRoot: true,\n      color: '#dc2626'\n    }]);\n    setConnections([]);\n    setTranslateX(0);\n    setTranslateY(0);\n    setCurrentMindMapId(null); // Clear current ID to indicate a new map\n    setCurrentMapTitle('Untitled Map');\n    setMessage('Created a new, empty mind map.');\n    navigate('/mindmap/new', {\n      replace: true\n    }); // Ensure URL reflects new map state\n  }, [navigate]);\n  const handleSetMapTitle = useCallback(newTitle => {\n    setCurrentMapTitle(newTitle);\n    // Optionally, save the title immediately or mark for save\n    // For now, it will be saved with the next full map save\n  }, []);\n\n  // --- Mouse Handlers for Node Dragging (no changes needed here) ---\n  const handleMouseMove = useCallback(e => {\n    if (!dragDataRef.current.isDragging || !draggedNode) return;\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    animationFrameRef.current = requestAnimationFrame(() => {\n      var _containerRef$current;\n      const rect = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.getBoundingClientRect();\n      if (!rect) return;\n      const newX = e.clientX - rect.left - dragDataRef.current.offset.x - translateX;\n      const newY = e.clientY - rect.top - dragDataRef.current.offset.y - translateY;\n      setNodes(prev => prev.map(node => node.id === draggedNode ? {\n        ...node,\n        x: newX,\n        y: newY\n      } : node));\n    });\n  }, [draggedNode, translateX, translateY]);\n  const handleMouseDown = useCallback((e, nodeId) => {\n    var _containerRef$current2;\n    e.preventDefault();\n    e.stopPropagation();\n    if (selectedNode !== nodeId) {\n      setSelectedNode(nodeId);\n    }\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.add('no-transition');\n    }\n    const node = nodes.find(n => n.id === nodeId);\n    if (!node) return;\n    const nodeEl = e.currentTarget;\n    if (!nodeEl) return;\n    const nodeRect = nodeEl.getBoundingClientRect();\n    const containerRect = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.getBoundingClientRect();\n    if (!containerRect) return;\n    dragDataRef.current = {\n      isDragging: true,\n      offset: {\n        x: e.clientX - nodeRect.left,\n        y: e.clientY - nodeRect.top\n      }\n    };\n    setDraggedNode(nodeId);\n  }, [nodes, selectedNode]);\n  const handleMouseUp = useCallback(() => {\n    dragDataRef.current.isDragging = false;\n    setDraggedNode(null);\n    setIsPanning(false);\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.remove('no-transition');\n    }\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, []);\n  const handlePanMouseDown = useCallback(e => {\n    const isTargetNode = e.target.closest('.mindmap-node');\n    const isTargetToolbar = e.target.closest('.mindmap-toolbar');\n    const isTargetInstructions = e.target.closest('.mindmap-instructions');\n    const isTargetLargeEditor = e.target.closest('.large-text-editor-overlay');\n    if (isTargetNode || isTargetToolbar || isTargetInstructions || isTargetLargeEditor || e.button !== 0) {\n      return;\n    }\n    setIsPanning(true);\n    panStartRef.current = {\n      x: e.clientX,\n      y: e.clientY,\n      startTranslateX: translateX,\n      startTranslateY: translateY\n    };\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.add('no-transition');\n    }\n    setSelectedNode(null);\n    e.preventDefault();\n  }, [translateX, translateY]);\n  const handlePanMouseMove = useCallback(e => {\n    if (!isPanning) return;\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    animationFrameRef.current = requestAnimationFrame(() => {\n      const dx = e.clientX - panStartRef.current.x;\n      const dy = e.clientY - panStartRef.current.y;\n      setTranslateX(panStartRef.current.startTranslateX + dx);\n      setTranslateY(panStartRef.current.startTranslateY + dy);\n    });\n  }, [isPanning]);\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n    const handleGlobalMove = e => {\n      if (draggedNode) {\n        handleMouseMove(e);\n      } else if (isPanning) {\n        handlePanMouseMove(e);\n      }\n    };\n    const handleGlobalUp = () => handleMouseUp();\n    const handlePanDown = e => handlePanMouseDown(e);\n    document.addEventListener('mouseup', handleGlobalUp);\n    document.addEventListener('mouseleave', handleGlobalUp);\n    container.addEventListener('mousemove', handleGlobalMove);\n    container.addEventListener('mousedown', handlePanDown);\n    return () => {\n      document.removeEventListener('mouseup', handleGlobalUp);\n      document.removeEventListener('mouseleave', handleGlobalUp);\n      container.removeEventListener('mousemove', handleGlobalMove);\n      container.removeEventListener('mousedown', handlePanDown);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      const currentCanvasWrapper = canvasWrapperRef.current;\n      if (currentCanvasWrapper) {\n        currentCanvasWrapper.classList.remove('no-transition');\n      }\n    };\n  }, [handleMouseMove, handleMouseUp, handlePanMouseDown, handlePanMouseMove, draggedNode, isPanning]);\n  const closeLargeEditor = useCallback(() => {\n    setIsLargeEditorOpen(false);\n    setLargeEditorNodeId(null);\n    setLargeEditorTitle('');\n    setLargeEditorText('');\n  }, []);\n  const saveLargeEditorText = useCallback((newTitle, newText) => {\n    if (!largeEditorNodeId) return;\n    setNodes(prev => prev.map(node => node.id === largeEditorNodeId ? {\n      ...node,\n      title: newTitle.trim() || 'New Idea',\n      text: newText.trim() || ''\n    } : node));\n    closeLargeEditor();\n  }, [largeEditorNodeId, closeLargeEditor]);\n  const openLargeEditor = useCallback(nodeId => {\n    const node = nodes.find(n => n.id === nodeId);\n    if (node) {\n      setIsLargeEditorOpen(true);\n      setLargeEditorNodeId(nodeId);\n      setLargeEditorTitle(node.title || '');\n      setLargeEditorText(node.text || '');\n    }\n  }, [nodes]);\n  const addNode = useCallback(() => {\n    const parent = selectedNode ? nodes.find(n => n.id === selectedNode) : nodes.find(n => n.isRoot);\n    if (!parent) {\n      setMessage('Cannot add node: No root node found or selected node does not exist.');\n      return;\n    }\n    const angle = Math.random() * 2 * Math.PI;\n    const distance = 150;\n    const newNode = {\n      id: Date.now().toString(),\n      x: parent.x + Math.cos(angle) * distance,\n      y: parent.y + Math.sin(angle) * distance,\n      title: 'New Idea',\n      text: '',\n      color: colors[Math.floor(Math.random() * colors.length)]\n    };\n    setNodes(prev => [...prev, newNode]);\n    setConnections(prev => [...prev, {\n      from: parent.id,\n      to: newNode.id\n    }]);\n    setSelectedNode(newNode.id);\n    openLargeEditor(newNode.id);\n  }, [nodes, colors, selectedNode, openLargeEditor]);\n  const deleteNode = useCallback(() => {\n    const nodeToDelete = nodes.find(n => n.id === selectedNode);\n    if (!nodeToDelete || nodeToDelete.isRoot) {\n      setMessage('Cannot delete root node or no node selected.');\n      return;\n    }\n    setNodes(prev => prev.filter(n => n.id !== selectedNode));\n    setConnections(prev => prev.filter(c => c.from !== selectedNode && c.to !== selectedNode));\n    setSelectedNode(null);\n  }, [nodes, selectedNode]);\n  const isRootSelected = selectedNode ? (_nodes$find = nodes.find(n => n.id === selectedNode)) === null || _nodes$find === void 0 ? void 0 : _nodes$find.isRoot : false;\n\n  // REMOVE THIS BLOCK - Authentication is now handled by ProtectedRoute in App.js\n  // if (!session) {\n  //   return <Auth onAuthSuccess={handleAuthSuccess} />;\n  // }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"mindmap-container\",\n    ref: containerRef,\n    children: [/*#__PURE__*/_jsxDEV(MindMapToolbar, {\n      onAddNode: addNode,\n      onEditNode: () => selectedNode && openLargeEditor(selectedNode),\n      onDeleteNode: deleteNode,\n      selectedNode: selectedNode,\n      isRootSelected: isRootSelected,\n      onSave: saveMindMapToServer,\n      onLoadMap: loadMindMapFromServer,\n      onNewMap: handleNewMap,\n      userMindMaps: userMindMaps,\n      currentMindMapId: currentMindMapId,\n      loading: loading,\n      message: message,\n      onLogout: handleLogout,\n      userName: (session === null || session === void 0 ? void 0 : (_session$user = session.user) === null || _session$user === void 0 ? void 0 : _session$user.email) || 'User',\n      currentMapTitle: currentMapTitle,\n      onSetMapTitle: handleSetMapTitle\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 474,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MindMapInstructions, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 493,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MindMapCanvas, {\n      nodes: nodes,\n      connections: connections,\n      draggedNode: draggedNode,\n      selectedNode: selectedNode,\n      translateX: translateX,\n      translateY: translateY,\n      handleMouseDown: handleMouseDown,\n      openNodeEditor: openLargeEditor,\n      canvasWrapperRef: canvasWrapperRef,\n      svgRef: svgRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 495,\n      columnNumber: 7\n    }, this), isLargeEditorOpen && /*#__PURE__*/_jsxDEV(LargeTextEditor, {\n      isOpen: isLargeEditorOpen,\n      initialTitle: largeEditorTitle,\n      initialText: largeEditorText,\n      onSave: saveLargeEditorText,\n      onCancel: closeLargeEditor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 509,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 473,\n    columnNumber: 5\n  }, this);\n};\n_s(MindMap, \"cVzZzx1kgmsqNV4Okte9iJ4dwjg=\", false, function () {\n  return [useParams, useNavigate];\n});\n_c = MindMap;\nexport default MindMap;\nvar _c;\n$RefreshReg$(_c, \"MindMap\");","map":{"version":3,"names":["React","useState","useRef","useCallback","useEffect","useMemo","MindMapCanvas","MindMapToolbar","MindMapInstructions","LargeTextEditor","useParams","useNavigate","jsxDEV","_jsxDEV","API_BASE_URL","process","env","REACT_APP_BACKEND_API_URL","MindMap","_s","_nodes$find","_session$user","id","navigate","nodes","setNodes","x","y","title","text","isRoot","color","connections","setConnections","draggedNode","setDraggedNode","selectedNode","setSelectedNode","isLargeEditorOpen","setIsLargeEditorOpen","largeEditorNodeId","setLargeEditorNodeId","largeEditorTitle","setLargeEditorTitle","largeEditorText","setLargeEditorText","translateX","setTranslateX","translateY","setTranslateY","isPanning","setIsPanning","panStartRef","startTranslateX","startTranslateY","svgRef","containerRef","canvasWrapperRef","dragDataRef","isDragging","offset","animationFrameRef","colors","session","setSession","currentMindMapId","setCurrentMindMapId","currentMapTitle","setCurrentMapTitle","userMindMaps","setUserMindMaps","loading","setLoading","message","setMessage","storedSession","localStorage","getItem","parsedSession","JSON","parse","token","user","email","fetchUserMindMaps","removeItem","e","console","error","loadMindMapFromServer","handleNewMap","handleAuthSuccess","handleLogout","response","fetch","headers","ok","status","Error","statusText","data","json","saveMindMapToServer","mindMapData","viewState","method","body","stringify","errorData","savedMap","_id","mapId","_data$viewState","_data$viewState2","replace","handleSetMapTitle","newTitle","handleMouseMove","current","cancelAnimationFrame","requestAnimationFrame","_containerRef$current","rect","getBoundingClientRect","newX","clientX","left","newY","clientY","top","prev","map","node","handleMouseDown","nodeId","_containerRef$current2","preventDefault","stopPropagation","currentCanvasWrapper","classList","add","find","n","nodeEl","currentTarget","nodeRect","containerRect","handleMouseUp","remove","handlePanMouseDown","isTargetNode","target","closest","isTargetToolbar","isTargetInstructions","isTargetLargeEditor","button","handlePanMouseMove","dx","dy","container","handleGlobalMove","handleGlobalUp","handlePanDown","document","addEventListener","removeEventListener","closeLargeEditor","saveLargeEditorText","newText","trim","openLargeEditor","addNode","parent","angle","Math","random","PI","distance","newNode","Date","now","toString","cos","sin","floor","length","from","to","deleteNode","nodeToDelete","filter","c","isRootSelected","className","ref","children","onAddNode","onEditNode","onDeleteNode","onSave","onLoadMap","onNewMap","onLogout","userName","onSetMapTitle","fileName","_jsxFileName","lineNumber","columnNumber","openNodeEditor","isOpen","initialTitle","initialText","onCancel","_c","$RefreshReg$"],"sources":["/Users/jimmyzhou/Desktop/Projects/scripty/frontend/src/pages/mindmap.jsx"],"sourcesContent":["import React, { useState, useRef, useCallback, useEffect, useMemo } from 'react';\n\nimport MindMapCanvas from '../components/mindmapcanvas';\nimport MindMapToolbar from '../components/mindmaptoolbar';\nimport MindMapInstructions from '../components/mindmapinstructions';\nimport LargeTextEditor from '../components/mindmaptexteditor';\n// REMOVE THIS LINE: import Auth from '../pages/auth'; // <--- REMOVED IMPORT\nimport './mindmap.css';\nimport { useParams, useNavigate } from 'react-router-dom';\n\nconst API_BASE_URL = process.env.REACT_APP_BACKEND_API_URL || 'http://localhost:5001/api';\n\nconst MindMap = () => {\n  const { id } = useParams();\n  const navigate = useNavigate();\n  const [nodes, setNodes] = useState([\n    { id: '1', x: 400, y: 300, title: 'Central Idea', text: '', isRoot: true, color: '#dc2626' }\n  ]);\n  const [connections, setConnections] = useState([]);\n  const [draggedNode, setDraggedNode] = useState(null);\n  const [selectedNode, setSelectedNode] = useState(null);\n\n  const [isLargeEditorOpen, setIsLargeEditorOpen] = useState(false);\n  const [largeEditorNodeId, setLargeEditorNodeId] = useState(null);\n  const [largeEditorTitle, setLargeEditorTitle] = useState('');\n  const [largeEditorText, setLargeEditorText] = useState('');\n\n\n  const [translateX, setTranslateX] = useState(0);\n  const [translateY, setTranslateY] = useState(0);\n  const [isPanning, setIsPanning] = useState(false);\n  const panStartRef = useRef({ x: 0, y: 0, startTranslateX: 0, startTranslateY: 0 });\n\n  const svgRef = useRef(null);\n  const containerRef = useRef(null);\n  const canvasWrapperRef = useRef(null);\n\n  const dragDataRef = useRef({ isDragging: false, offset: { x: 0, y: 0 } });\n  const animationFrameRef = useRef(null);\n\n  const colors = useMemo(() => [\n    '#EF4444',\n    '#F97316',\n    '#EAB308',\n    '#22C55E',\n    '#3B82F6',\n    '#A855F7',\n    '#EC4899',\n  ], []);\n\n  // --- State for Backend Integration ---\n  const [session, setSession] = useState(null);\n  const [currentMindMapId, setCurrentMindMapId] = useState(null);\n  const [currentMapTitle, setCurrentMapTitle] = useState('Untitled Map');\n  const [userMindMaps, setUserMindMaps] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [message, setMessage] = useState('Welcome! Login or register to start creating.');\n\n  // --- Authentication & Session Management ---\n  // Note: The onAuthSuccess callback is no longer needed here as Auth handles navigation\n  // The session check in this useEffect will now redirect if there's no valid session,\n  // relying on ProtectedRoute to guard the path.\n  useEffect(() => {\n    const storedSession = localStorage.getItem('mindmapSession');\n    if (storedSession) {\n      try {\n        const parsedSession = JSON.parse(storedSession);\n        if (parsedSession && parsedSession.token && parsedSession.user) {\n          setSession(parsedSession);\n          setMessage(`Welcome back, ${parsedSession.user.email}!`);\n          fetchUserMindMaps(parsedSession.token);\n        } else {\n          localStorage.removeItem('mindmapSession'); // Clear invalid session\n          navigate('/'); // Redirect to login if session invalid\n        }\n      } catch (e) {\n        console.error(\"Failed to parse session from localStorage\", e);\n        localStorage.removeItem('mindmapSession');\n        navigate('/'); // Redirect to login if session parsing fails\n      }\n    } else {\n      navigate('/'); // Redirect to login if no session at all\n    }\n  // Added fetchUserMindMaps to dependency array for completeness and correctness\n  }, [navigate, fetchUserMindMaps]);\n\n  useEffect(() => {\n    if (!session) return; // Wait for session to be established\n    if (id && id !== 'new') {\n      loadMindMapFromServer(id);\n    } else if (id === 'new') {\n      handleNewMap();\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [session, id]); // Depend on session and id to trigger loading\n\n  const handleAuthSuccess = useCallback(() => {\n    // This callback is now effectively managed by the Auth component itself\n    // and is primarily for MindMap to react to a successful login if it's already rendered\n    // (though with ProtectedRoute, it won't be rendered unless logged in).\n    // The previous logic for calling fetchUserMindMaps is now handled in the useEffect above.\n  }, []); // No dependencies needed as it's not directly used for navigation anymore\n\n  const handleLogout = useCallback(() => {\n    setSession(null);\n    localStorage.removeItem('mindmapSession');\n    // Clear current map data and reset to a new default map\n    setNodes([{ id: '1', x: 400, y: 300, title: 'Central Idea', text: '', isRoot: true, color: '#dc2626' }]);\n    setConnections([]);\n    setTranslateX(0);\n    setTranslateY(0);\n    setCurrentMindMapId(null);\n    setCurrentMapTitle('Untitled Map');\n    setUserMindMaps([]); // Clear user maps on logout\n    setMessage('You have been logged out.');\n    navigate('/'); // Redirect to login page after logout\n  }, [navigate]); // Added navigate to dependency array\n\n  // --- API Calls (no changes needed here) ---\n\n  const fetchUserMindMaps = useCallback(async (token) => {\n    setLoading(true);\n    setMessage('Fetching your mind maps...');\n    try {\n      const response = await fetch(`${API_BASE_URL}/mindmaps`, {\n        headers: {\n          'Authorization': `Bearer ${token}`,\n        },\n      });\n\n      if (!response.ok) {\n        if (response.status === 401) {\n          setMessage('Session expired or unauthorized. Please log in again.');\n          handleLogout(); // Log out if unauthorized\n          return;\n        }\n        throw new Error(`Error fetching mind maps: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      setUserMindMaps(data);\n      setMessage('Your mind maps loaded!');\n    } catch (error) {\n      console.error('Fetch mind maps error:', error);\n      setMessage(`Failed to fetch mind maps: ${error.message}`);\n    } finally {\n      setLoading(false);\n    }\n  }, [handleLogout]);\n\n  const saveMindMapToServer = useCallback(async () => {\n    if (!session || !session.token) {\n      setMessage('Please log in to save your mind map.');\n      return;\n    }\n\n    setLoading(true);\n    setMessage('Saving mind map...');\n    try {\n      const mindMapData = {\n        title: currentMapTitle,\n        nodes,\n        connections,\n        viewState: { translateX, translateY },\n      };\n\n      let response;\n      if (currentMindMapId) {\n        // Update existing mind map\n        response = await fetch(`${API_BASE_URL}/mindmaps/${currentMindMapId}`, {\n          method: 'PUT',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${session.token}`,\n          },\n          body: JSON.stringify(mindMapData),\n        });\n      } else {\n        // Create new mind map\n        response = await fetch(`${API_BASE_URL}/mindmaps`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${session.token}`,\n          },\n          body: JSON.stringify(mindMapData),\n        });\n      }\n\n      if (!response.ok) {\n        if (response.status === 401) {\n          setMessage('Session expired or unauthorized. Please log in again to save.');\n          handleLogout();\n          return;\n        }\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Failed to save mind map');\n      }\n\n      const savedMap = await response.json();\n      setCurrentMindMapId(savedMap._id);\n      setCurrentMapTitle(savedMap.title);\n      setMessage('Mind map saved successfully!');\n      fetchUserMindMaps(session.token); // Refresh the list of maps\n    } catch (error) {\n      console.error('Save mind map error:', error);\n      setMessage(`Error saving mind map: ${error.message}`);\n    } finally {\n      setLoading(false);\n    }\n  }, [nodes, connections, translateX, translateY, currentMindMapId, currentMapTitle, session, fetchUserMindMaps, handleLogout]);\n\n  const loadMindMapFromServer = useCallback(async (mapId) => {\n    if (!session || !session.token) {\n      setMessage('Please log in to load a mind map.');\n      return;\n    }\n    setLoading(true);\n    setMessage('Loading mind map...');\n    try {\n      const response = await fetch(`${API_BASE_URL}/mindmaps/${mapId}`, {\n        headers: {\n          'Authorization': `Bearer ${session.token}`,\n        },\n      });\n\n      if (!response.ok) {\n        if (response.status === 401) {\n          setMessage('Session expired or unauthorized. Please log in again.');\n          handleLogout();\n          return;\n        }\n        throw new Error(`Error loading mind map: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      setNodes(data.nodes || []);\n      setConnections(data.connections || []);\n      setTranslateX(data.viewState?.translateX || 0);\n      setTranslateY(data.viewState?.translateY || 0);\n      setCurrentMindMapId(data._id);\n      setCurrentMapTitle(data.title);\n      setMessage(`Mind map \"${data.title}\" loaded!`);\n    } catch (error) {\n      console.error('Load mind map error:', error);\n      setMessage(`Failed to load mind map: ${error.message}`);\n    } finally {\n      setLoading(false);\n    }\n  }, [session, handleLogout]);\n\n  const handleNewMap = useCallback(() => {\n    setNodes([{ id: '1', x: 400, y: 300, title: 'Central Idea', text: '', isRoot: true, color: '#dc2626' }]);\n    setConnections([]);\n    setTranslateX(0);\n    setTranslateY(0);\n    setCurrentMindMapId(null); // Clear current ID to indicate a new map\n    setCurrentMapTitle('Untitled Map');\n    setMessage('Created a new, empty mind map.');\n    navigate('/mindmap/new', { replace: true }); // Ensure URL reflects new map state\n  }, [navigate]);\n\n\n  const handleSetMapTitle = useCallback((newTitle) => {\n    setCurrentMapTitle(newTitle);\n    // Optionally, save the title immediately or mark for save\n    // For now, it will be saved with the next full map save\n  }, []);\n\n  // --- Mouse Handlers for Node Dragging (no changes needed here) ---\n  const handleMouseMove = useCallback((e) => {\n    if (!dragDataRef.current.isDragging || !draggedNode) return;\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    animationFrameRef.current = requestAnimationFrame(() => {\n      const rect = containerRef.current?.getBoundingClientRect();\n      if (!rect) return;\n      const newX = (e.clientX - rect.left - dragDataRef.current.offset.x - translateX);\n      const newY = (e.clientY - rect.top - dragDataRef.current.offset.y - translateY);\n      setNodes(prev => prev.map(node =>\n        node.id === draggedNode\n          ? { ...node, x: newX, y: newY }\n          : node\n      ));\n    });\n  }, [draggedNode, translateX, translateY]);\n\n  const handleMouseDown = useCallback((e, nodeId) => {\n    e.preventDefault();\n    e.stopPropagation();\n    if (selectedNode !== nodeId) {\n      setSelectedNode(nodeId);\n    }\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.add('no-transition');\n    }\n    const node = nodes.find(n => n.id === nodeId);\n    if (!node) return;\n    const nodeEl = e.currentTarget;\n    if (!nodeEl) return;\n    const nodeRect = nodeEl.getBoundingClientRect();\n    const containerRect = containerRef.current?.getBoundingClientRect();\n    if (!containerRect) return;\n\n    dragDataRef.current = {\n      isDragging: true,\n      offset: {\n        x: e.clientX - nodeRect.left,\n        y: e.clientY - nodeRect.top\n      }\n    };\n    setDraggedNode(nodeId);\n  }, [nodes, selectedNode]);\n\n  const handleMouseUp = useCallback(() => {\n    dragDataRef.current.isDragging = false;\n    setDraggedNode(null);\n    setIsPanning(false);\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.remove('no-transition');\n    }\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, []);\n\n  const handlePanMouseDown = useCallback((e) => {\n    const isTargetNode = e.target.closest('.mindmap-node');\n    const isTargetToolbar = e.target.closest('.mindmap-toolbar');\n    const isTargetInstructions = e.target.closest('.mindmap-instructions');\n    const isTargetLargeEditor = e.target.closest('.large-text-editor-overlay');\n    if (isTargetNode || isTargetToolbar || isTargetInstructions || isTargetLargeEditor || e.button !== 0) {\n        return;\n    }\n    setIsPanning(true);\n    panStartRef.current = {\n      x: e.clientX,\n      y: e.clientY,\n      startTranslateX: translateX,\n      startTranslateY: translateY\n    };\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.add('no-transition');\n    }\n    setSelectedNode(null);\n    e.preventDefault();\n  }, [translateX, translateY]);\n\n  const handlePanMouseMove = useCallback((e) => {\n    if (!isPanning) return;\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    animationFrameRef.current = requestAnimationFrame(() => {\n      const dx = e.clientX - panStartRef.current.x;\n      const dy = e.clientY - panStartRef.current.y;\n      setTranslateX(panStartRef.current.startTranslateX + dx);\n      setTranslateY(panStartRef.current.startTranslateY + dy);\n    });\n  }, [isPanning]);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const handleGlobalMove = (e) => {\n      if (draggedNode) {\n        handleMouseMove(e);\n      } else if (isPanning) {\n        handlePanMouseMove(e);\n      }\n    };\n\n    const handleGlobalUp = () => handleMouseUp();\n\n    const handlePanDown = (e) => handlePanMouseDown(e);\n\n    document.addEventListener('mouseup', handleGlobalUp);\n    document.addEventListener('mouseleave', handleGlobalUp);\n    container.addEventListener('mousemove', handleGlobalMove);\n    container.addEventListener('mousedown', handlePanDown);\n\n    return () => {\n      document.removeEventListener('mouseup', handleGlobalUp);\n      document.removeEventListener('mouseleave', handleGlobalUp);\n      container.removeEventListener('mousemove', handleGlobalMove);\n      container.removeEventListener('mousedown', handlePanDown);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      const currentCanvasWrapper = canvasWrapperRef.current;\n      if (currentCanvasWrapper) {\n        currentCanvasWrapper.classList.remove('no-transition');\n      }\n    };\n  }, [handleMouseMove, handleMouseUp, handlePanMouseDown, handlePanMouseMove, draggedNode, isPanning]);\n\n  const closeLargeEditor = useCallback(() => {\n    setIsLargeEditorOpen(false);\n    setLargeEditorNodeId(null);\n    setLargeEditorTitle('');\n    setLargeEditorText('');\n  }, []);\n\n  const saveLargeEditorText = useCallback((newTitle, newText) => {\n    if (!largeEditorNodeId) return;\n    setNodes(prev =>\n      prev.map(node => (\n        node.id === largeEditorNodeId\n          ? { ...node, title: newTitle.trim() || 'New Idea', text: newText.trim() || '' }\n          : node\n      ))\n    );\n    closeLargeEditor();\n  }, [largeEditorNodeId, closeLargeEditor]);\n\n  const openLargeEditor = useCallback((nodeId) => {\n    const node = nodes.find(n => n.id === nodeId);\n    if (node) {\n      setIsLargeEditorOpen(true);\n      setLargeEditorNodeId(nodeId);\n      setLargeEditorTitle(node.title || '');\n      setLargeEditorText(node.text || '');\n    }\n  }, [nodes]);\n\n  const addNode = useCallback(() => {\n    const parent = selectedNode ? nodes.find(n => n.id === selectedNode) : nodes.find(n => n.isRoot);\n    if (!parent) {\n      setMessage('Cannot add node: No root node found or selected node does not exist.');\n      return;\n    }\n    const angle = Math.random() * 2 * Math.PI;\n    const distance = 150;\n    const newNode = {\n      id: Date.now().toString(),\n      x: parent.x + Math.cos(angle) * distance,\n      y: parent.y + Math.sin(angle) * distance,\n      title: 'New Idea',\n      text: '',\n      color: colors[Math.floor(Math.random() * colors.length)]\n    };\n    setNodes(prev => [...prev, newNode]);\n    setConnections(prev => [...prev, { from: parent.id, to: newNode.id }]);\n    setSelectedNode(newNode.id);\n    openLargeEditor(newNode.id);\n  }, [nodes, colors, selectedNode, openLargeEditor]);\n\n  const deleteNode = useCallback(() => {\n    const nodeToDelete = nodes.find(n => n.id === selectedNode);\n    if (!nodeToDelete || nodeToDelete.isRoot) {\n      setMessage('Cannot delete root node or no node selected.');\n      return;\n    }\n    setNodes(prev => prev.filter(n => n.id !== selectedNode));\n    setConnections(prev => prev.filter(c => c.from !== selectedNode && c.to !== selectedNode));\n    setSelectedNode(null);\n  }, [nodes, selectedNode]);\n\n  const isRootSelected = selectedNode ? nodes.find(n => n.id === selectedNode)?.isRoot : false;\n\n  // REMOVE THIS BLOCK - Authentication is now handled by ProtectedRoute in App.js\n  // if (!session) {\n  //   return <Auth onAuthSuccess={handleAuthSuccess} />;\n  // }\n\n  return (\n    <div className=\"mindmap-container\" ref={containerRef}>\n      <MindMapToolbar\n        onAddNode={addNode}\n        onEditNode={() => selectedNode && openLargeEditor(selectedNode)}\n        onDeleteNode={deleteNode}\n        selectedNode={selectedNode}\n        isRootSelected={isRootSelected}\n        onSave={saveMindMapToServer}\n        onLoadMap={loadMindMapFromServer}\n        onNewMap={handleNewMap}\n        userMindMaps={userMindMaps}\n        currentMindMapId={currentMindMapId}\n        loading={loading}\n        message={message}\n        onLogout={handleLogout}\n        userName={session?.user?.email || 'User'}\n        currentMapTitle={currentMapTitle}\n        onSetMapTitle={handleSetMapTitle}\n      />\n\n      <MindMapInstructions />\n\n      <MindMapCanvas\n        nodes={nodes}\n        connections={connections}\n        draggedNode={draggedNode}\n        selectedNode={selectedNode}\n        translateX={translateX}\n        translateY={translateY}\n        handleMouseDown={handleMouseDown}\n        openNodeEditor={openLargeEditor}\n        canvasWrapperRef={canvasWrapperRef}\n        svgRef={svgRef}\n      />\n\n      {isLargeEditorOpen && (\n        <LargeTextEditor\n          isOpen={isLargeEditorOpen}\n          initialTitle={largeEditorTitle}\n          initialText={largeEditorText}\n          onSave={saveLargeEditorText}\n          onCancel={closeLargeEditor}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default MindMap;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}