{"ast":null,"code":"var _jsxFileName = \"/Users/jimmyzhou/Desktop/Projects/scripty/frontend/src/pages/mindmap.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { createClient } from '@supabase/supabase-js';\nimport MindMapCanvas from '../components/mindmapcanvas';\nimport MindMapToolbar from '../components/mindmaptoolbar';\nimport MindMapInstructions from '../components/mindmapinstructions';\nimport LargeTextEditor from '../components/mindmaptexteditor';\nimport Auth from '../components/Auth';\nimport './mindmap.css';\n\n// --- Supabase Client Initialization ---\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL;\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;\n\n// Log error if Supabase keys are missing in frontend .env\nif (!supabaseUrl || !supabaseAnonKey) {\n  console.error('REACT_APP_SUPABASE_URL or REACT_APP_SUPABASE_ANON_KEY is missing in frontend .env file.');\n  // In a production app, you might want to display a more prominent error to the user\n}\nconst supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// --- Backend API URL ---\nconst API_BASE_URL = process.env.REACT_APP_BACKEND_API_URL;\nif (!API_BASE_URL) {\n  console.error('REACT_APP_BACKEND_API_URL is not defined in frontend .env file. API calls will fail.');\n}\nconst MindMap = () => {\n  _s();\n  var _nodes$find, _session$user;\n  // --- Mind Map State ---\n  const [nodes, setNodes] = useState([{\n    id: '1',\n    x: 400,\n    y: 300,\n    title: 'Central Idea',\n    text: '',\n    isRoot: true,\n    color: '#dc2626'\n  }]);\n  const [connections, setConnections] = useState([]);\n  const [draggedNode, setDraggedNode] = useState(null);\n  const [selectedNode, setSelectedNode] = useState(null);\n\n  // --- Large Text Editor State ---\n  const [isLargeEditorOpen, setIsLargeEditorOpen] = useState(false);\n  const [largeEditorNodeId, setLargeEditorNodeId] = useState(null);\n  const [largeEditorTitle, setLargeEditorTitle] = useState('');\n  const [largeEditorText, setLargeEditorText] = '';\n\n  // --- Canvas Panning/Transform State ---\n  const [translateX, setTranslateX] = useState(0);\n  const [translateY, setTranslateY] = useState(0);\n  const [isPanning, setIsPanning] = useState(false);\n  const panStartRef = useRef({\n    x: 0,\n    y: 0,\n    startTranslateX: 0,\n    startTranslateY: 0\n  });\n\n  // --- Refs for DOM elements ---\n  const svgRef = useRef(null);\n  const containerRef = useRef(null);\n  const canvasWrapperRef = useRef(null);\n\n  // --- Dragging Refs and Animation Frame ---\n  const dragDataRef = useRef({\n    isDragging: false,\n    offset: {\n      x: 0,\n      y: 0\n    }\n  });\n  const animationFrameRef = useRef(null);\n\n  // --- Node Colors ---\n  const colors = useMemo(() => ['#EF4444',\n  // Red\n  '#F97316',\n  // Orange\n  '#EAB308',\n  // Yellow\n  '#22C55E',\n  // Green\n  '#3B82F6',\n  // Blue\n  '#A855F7',\n  // Purple\n  '#EC4899' // Pink\n  ], []);\n\n  // --- Authentication and Persistence States ---\n  const [session, setSession] = useState(null);\n  const [mindmapId, setMindmapId] = useState(null); // ID of the currently loaded/saved mind map\n  const [loading, setLoading] = useState(false); // General loading state for API operations\n  const [message, setMessage] = useState(''); // User feedback message\n  const [initialLoadAttempted, setInitialLoadAttempted] = useState(false); // To prevent redundant initial loads\n\n  // --- Backend API Save Function ---\n  const saveMindMap = useCallback(async () => {\n    // Prevent saving if not authenticated\n    if (!session || !session.access_token) {\n      setMessage('You must be logged in to save your mind map. Please log in.');\n      return;\n    }\n    // Prevent multiple save calls if one is already in progress\n    if (loading) {\n      setMessage('Save in progress...');\n      return;\n    }\n    setLoading(true);\n    setMessage('Saving mind map...');\n    const mindMapData = {\n      mindmapId,\n      // Will be null for new maps, ID for existing maps\n      name: 'My Awesome Mind Map',\n      // You might want to make this dynamic later\n      nodes_data: nodes,\n      connections_data: connections,\n      translate_x: translateX,\n      translate_y: translateY\n    };\n    try {\n      const response = await fetch(`${API_BASE_URL}/mindmaps`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session.access_token}` // Send JWT for authentication\n        },\n        body: JSON.stringify(mindMapData)\n      });\n\n      // Check for non-OK response (e.g., 4xx, 5xx status codes)\n      if (!response.ok) {\n        let errorData;\n        try {\n          errorData = await response.json(); // Try to parse error message from backend\n        } catch (parseError) {\n          console.error('Failed to parse error response during save:', parseError);\n          setMessage(`Error saving mind map: Server responded with status ${response.status} but no valid JSON error message.`);\n          return;\n        }\n        const errorMessage = errorData.message || errorData.error || `Unknown error (Status: ${response.status})`;\n        throw new Error(errorMessage);\n      }\n      const result = await response.json();\n      setMindmapId(result.data.id); // Update mindmapId with the ID of the saved map\n      setMessage('Mind map saved successfully!');\n      console.log('Mind map saved:', result.data);\n    } catch (error) {\n      setMessage(`Error saving mind map: ${error.message}.`);\n      console.error('Error saving mind map:', error);\n    } finally {\n      setLoading(false); // Reset loading state\n    }\n  }, [session, nodes, connections, translateX, translateY, mindmapId, loading]);\n\n  // --- Backend API Load Function ---\n  const loadMindMap = useCallback(async () => {\n    // Prevent loading if not authenticated\n    if (!session || !session.access_token) {\n      setMessage('Please log in to load your mind map.');\n      // Optionally reset to default if not logged in to avoid showing stale data\n      setNodes([{\n        id: '1',\n        x: 400,\n        y: 300,\n        title: 'Central Idea',\n        text: '',\n        isRoot: true,\n        color: '#dc2626'\n      }]);\n      setConnections([]);\n      setTranslateX(0);\n      setTranslateY(0);\n      setMindmapId(null);\n      return;\n    }\n    // Prevent multiple load calls if one is already in progress\n    if (loading) {\n      setMessage('Load in progress...');\n      return;\n    }\n    setLoading(true);\n    setMessage('Loading mind map...');\n    try {\n      const response = await fetch(`${API_BASE_URL}/mindmaps`, {\n        headers: {\n          'Authorization': `Bearer ${session.access_token}` // Send JWT for authentication\n        }\n      });\n\n      // Handle non-OK responses\n      if (!response.ok) {\n        if (response.status === 404) {\n          // Specific handling for \"no mind map found\"\n          setMessage('No mind map found for this user. You can start creating one now!');\n          // Initialize with a default central idea for a new user\n          setNodes([{\n            id: '1',\n            x: 400,\n            y: 300,\n            title: 'Central Idea',\n            text: '',\n            isRoot: true,\n            color: '#dc2626'\n          }]);\n          setConnections([]);\n          setTranslateX(0);\n          setTranslateY(0);\n          setMindmapId(null); // Ensure mindmapId is null for a new, unsaved map\n          return; // Exit as this is a handled scenario\n        }\n        let errorData;\n        try {\n          errorData = await response.json(); // Try to parse other error messages\n        } catch (parseError) {\n          console.error('Failed to parse error response during load:', parseError);\n          setMessage(`Error loading mind map: Server responded with status ${response.status} but no valid JSON error message.`);\n          return;\n        }\n        const errorMessage = errorData.message || errorData.error || `Unknown error (Status: ${response.status})`;\n        throw new Error(errorMessage);\n      }\n      const result = await response.json();\n      const loadedMap = result.data;\n      setNodes(loadedMap.nodes_data);\n      setConnections(loadedMap.connections_data);\n      setTranslateX(loadedMap.translate_x);\n      setTranslateY(loadedMap.translate_y);\n      setMindmapId(loadedMap.id);\n      setMessage('Mind map loaded successfully!');\n      console.log('Mind map loaded:', loadedMap);\n    } catch (error) {\n      setMessage(`Error loading mind map: ${error.message}. Please try again or re-authenticate.`);\n      console.error('Error loading mind map:', error);\n    } finally {\n      setLoading(false); // Reset loading state\n    }\n  }, [session, loading]); // Dependencies: session (for token), loading (to prevent re-entry)\n\n  // --- Supabase Authentication State Management ---\n  useEffect(() => {\n    // This function handles both initial session retrieval and subsequent auth state changes\n    const handleAuthEvent = async (event, currentSession) => {\n      console.log('Auth Event:', event, 'Session:', currentSession); // Detailed logging for debugging\n      setSession(currentSession);\n      if (currentSession) {\n        // Only trigger loadMindMap if user just signed in, token was refreshed, or if it's the very first load attempt\n        if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED' || !initialLoadAttempted) {\n          setMessage('Logged in. Loading your mind map...');\n          await loadMindMap(); // Wait for load to complete before marking as attempted\n          setInitialLoadAttempted(true); // Mark that an initial load has been attempted\n        } else {\n          // If already authenticated and not an event that requires a re-load, just update message\n          setMessage('You are logged in.');\n        }\n      } else {\n        // User is logged out (either SIGNED_OUT or no session initially)\n        setMessage('Logged out. Please log in or sign up.');\n        // Reset mind map state to default when user logs out\n        setNodes([{\n          id: '1',\n          x: 400,\n          y: 300,\n          title: 'Central Idea',\n          text: '',\n          isRoot: true,\n          color: '#dc2626'\n        }]);\n        setConnections([]);\n        setTranslateX(0);\n        setTranslateY(0);\n        setMindmapId(null);\n        setInitialLoadAttempted(false); // Reset this for the next login attempt\n      }\n    };\n\n    // 1. Get the initial session when the component mounts\n    supabase.auth.getSession().then(({\n      data: {\n        session: initialSession\n      }\n    }) => {\n      handleAuthEvent('INITIAL_LOAD', initialSession); // Use a custom event type for clarity\n    });\n\n    // 2. Subscribe to real-time authentication state changes\n    const {\n      data: {\n        subscription\n      }\n    } = supabase.auth.onAuthStateChange(handleAuthEvent);\n\n    // Clean up the subscription when the component unmounts\n    return () => subscription.unsubscribe();\n  }, [loadMindMap, initialLoadAttempted]); // Dependencies: loadMindMap and initialLoadAttempted\n\n  // Callback from Auth component after successful login/signup\n  const handleAuthSuccess = useCallback(async newSession => {\n    setMessage('Authentication successful. Loading your mind map...');\n    setSession(newSession); // Update session immediately\n    await loadMindMap(); // Load map immediately after successful auth\n    setInitialLoadAttempted(true); // Mark as attempted\n  }, [loadMindMap]);\n\n  // Logout function\n  const handleLogout = useCallback(async () => {\n    setLoading(true);\n    setMessage('Logging out...');\n    try {\n      const {\n        error\n      } = await supabase.auth.signOut();\n      if (error) throw error;\n      setMessage('Logged out successfully.');\n      // The `onAuthStateChange` listener will handle the state reset after signOut\n    } catch (error) {\n      setMessage(`Logout error: ${error.message}`);\n      console.error('Logout error:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // --- Mouse Handlers for Node Dragging ---\n  const handleMouseMove = useCallback(e => {\n    if (!dragDataRef.current.isDragging || !draggedNode) return;\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    animationFrameRef.current = requestAnimationFrame(() => {\n      var _containerRef$current;\n      const rect = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.getBoundingClientRect();\n      if (!rect) return;\n      // Calculate new position relative to the container and current pan\n      const newX = e.clientX - rect.left - dragDataRef.current.offset.x - translateX;\n      const newY = e.clientY - rect.top - dragDataRef.current.offset.y - translateY;\n      setNodes(prev => prev.map(node => node.id === draggedNode ? {\n        ...node,\n        x: newX,\n        y: newY\n      } : node));\n    });\n  }, [draggedNode, translateX, translateY]);\n  const handleMouseDown = useCallback((e, nodeId) => {\n    var _containerRef$current2;\n    e.preventDefault();\n    e.stopPropagation(); // Prevent canvas panning from starting when clicking a node\n    if (selectedNode !== nodeId) {\n      setSelectedNode(nodeId);\n    }\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.add('no-transition'); // Disable transition during drag\n    }\n    const node = nodes.find(n => n.id === nodeId);\n    if (!node) return;\n    const nodeEl = e.currentTarget; // Get the DOM element for the node\n    if (!nodeEl) return;\n    const nodeRect = nodeEl.getBoundingClientRect();\n    const containerRect = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.getBoundingClientRect();\n    if (!containerRect) return;\n\n    // Calculate offset from mouse click to node's top-left corner\n    dragDataRef.current = {\n      isDragging: true,\n      offset: {\n        x: e.clientX - nodeRect.left,\n        y: e.clientY - nodeRect.top\n      }\n    };\n    setDraggedNode(nodeId);\n  }, [nodes, selectedNode]);\n  const handleMouseUp = useCallback(() => {\n    dragDataRef.current.isDragging = false;\n    setDraggedNode(null);\n    setIsPanning(false); // Ensure panning state is reset\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.remove('no-transition'); // Re-enable transition after drag\n    }\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, []);\n\n  // --- Mouse Handlers for Panning ---\n  const handlePanMouseDown = useCallback(e => {\n    // Only pan if a node, toolbar, instructions, or editor isn't clicked AND it's the left mouse button\n    const isTargetNode = e.target.closest('.mindmap-node');\n    const isTargetToolbar = e.target.closest('.mindmap-toolbar');\n    const isTargetInstructions = e.target.closest('.mindmap-instructions');\n    const isTargetLargeEditor = e.target.closest('.large-text-editor-overlay');\n    if (isTargetNode || isTargetToolbar || isTargetInstructions || isTargetLargeEditor || e.button !== 0) {\n      return;\n    }\n    setIsPanning(true);\n    panStartRef.current = {\n      x: e.clientX,\n      y: e.clientY,\n      startTranslateX: translateX,\n      startTranslateY: translateY\n    };\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.add('no-transition');\n    }\n    setSelectedNode(null); // Deselect any node when panning starts\n    e.preventDefault(); // Prevent default browser drag behavior (e.g., image dragging)\n  }, [translateX, translateY]);\n  const handlePanMouseMove = useCallback(e => {\n    if (!isPanning) return;\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    animationFrameRef.current = requestAnimationFrame(() => {\n      const dx = e.clientX - panStartRef.current.x;\n      const dy = e.clientY - panStartRef.current.y;\n      setTranslateX(panStartRef.current.startTranslateX + dx);\n      setTranslateY(panStartRef.current.startTranslateY + dy);\n    });\n  }, [isPanning]);\n\n  // Global mouse event listeners for dragging and panning\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return; // Ensure container ref is available\n\n    const handleGlobalMove = e => {\n      if (draggedNode) {\n        handleMouseMove(e);\n      } else if (isPanning) {\n        handlePanMouseMove(e);\n      }\n    };\n    const handleGlobalUp = () => handleMouseUp(); // This function resets all dragging/panning states\n\n    const handlePanDown = e => handlePanMouseDown(e); // Listener for canvas pan initiation\n\n    // Attach listeners to document for robust dragging/panning even if mouse leaves container\n    document.addEventListener('mouseup', handleGlobalUp);\n    document.addEventListener('mouseleave', handleGlobalUp); // Important for when mouse leaves browser window\n    container.addEventListener('mousemove', handleGlobalMove); // Listen on container for mouse movement\n    container.addEventListener('mousedown', handlePanDown); // Listen on container for pan start\n\n    // Cleanup function\n    return () => {\n      document.removeEventListener('mouseup', handleGlobalUp);\n      document.removeEventListener('mouseleave', handleGlobalUp);\n      container.removeEventListener('mousemove', handleGlobalMove);\n      container.removeEventListener('mousedown', handlePanDown);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      // Ensure no-transition class is removed on unmount too\n      const currentCanvasWrapper = canvasWrapperRef.current;\n      if (currentCanvasWrapper) {\n        currentCanvasWrapper.classList.remove('no-transition');\n      }\n    };\n  }, [handleMouseMove, handleMouseUp, handlePanMouseDown, handlePanMouseMove, draggedNode, isPanning]);\n\n  // --- Large Text Editor Functions ---\n  const closeLargeEditor = useCallback(() => {\n    setIsLargeEditorOpen(false);\n    setLargeEditorNodeId(null);\n    setLargeEditorTitle('');\n    setLargeEditorText('');\n  }, []);\n  const saveLargeEditorText = useCallback((newTitle, newText) => {\n    if (!largeEditorNodeId) return;\n    setNodes(prev => prev.map(node => node.id === largeEditorNodeId ? {\n      ...node,\n      title: newTitle.trim() || 'New Idea',\n      text: newText.trim() || ''\n    } : node));\n    closeLargeEditor();\n  }, [largeEditorNodeId, closeLargeEditor]);\n  const openLargeEditor = useCallback(nodeId => {\n    const node = nodes.find(n => n.id === nodeId);\n    if (node) {\n      setIsLargeEditorOpen(true);\n      setLargeEditorNodeId(nodeId);\n      setLargeEditorTitle(node.title || '');\n      setLargeEditorText(node.text || '');\n    }\n  }, [nodes]);\n\n  // --- Mind Map Node Operations ---\n  const addNode = useCallback(() => {\n    const parent = selectedNode ? nodes.find(n => n.id === selectedNode) : nodes.find(n => n.isRoot);\n    if (!parent) {\n      setMessage('Cannot add node: No root node found or selected node does not exist.');\n      return;\n    }\n    const angle = Math.random() * 2 * Math.PI; // Random angle for new node placement\n    const distance = 150; // Distance from parent\n    const newNode = {\n      id: Date.now().toString(),\n      // Unique ID for new node\n      x: parent.x + Math.cos(angle) * distance,\n      y: parent.y + Math.sin(angle) * distance,\n      title: 'New Idea',\n      text: '',\n      color: colors[Math.floor(Math.random() * colors.length)] // Random color\n    };\n    setNodes(prev => [...prev, newNode]);\n    setConnections(prev => [...prev, {\n      from: parent.id,\n      to: newNode.id\n    }]);\n    setSelectedNode(newNode.id); // Select the newly created node\n    openLargeEditor(newNode.id); // Open editor for new node\n  }, [nodes, colors, selectedNode, openLargeEditor]);\n  const deleteNode = useCallback(() => {\n    const nodeToDelete = nodes.find(n => n.id === selectedNode);\n    if (!nodeToDelete || nodeToDelete.isRoot) {\n      setMessage('Cannot delete root node or no node selected.');\n      return;\n    }\n    setNodes(prev => prev.filter(n => n.id !== selectedNode)); // Remove node\n    setConnections(prev => prev.filter(c => c.from !== selectedNode && c.to !== selectedNode)); // Remove related connections\n    setSelectedNode(null); // Deselect after deleting\n  }, [nodes, selectedNode]);\n\n  // Helper to check if the selected node is the root\n  const isRootSelected = selectedNode ? (_nodes$find = nodes.find(n => n.id === selectedNode)) === null || _nodes$find === void 0 ? void 0 : _nodes$find.isRoot : false;\n\n  // --- Conditional Rendering for Authentication ---\n  // If no session, render the Auth component\n  if (!session) {\n    return /*#__PURE__*/_jsxDEV(Auth, {\n      onAuthSuccess: handleAuthSuccess\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 496,\n      columnNumber: 12\n    }, this);\n  }\n\n  // --- Main Mind Map UI Rendering ---\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"mindmap-container\",\n    ref: containerRef,\n    children: [/*#__PURE__*/_jsxDEV(MindMapToolbar, {\n      onAddNode: addNode\n      // The comment explaining the onEditNode prop should be a regular JavaScript comment\n      // above the prop or within the function if it's complex, not a separate JSX comment.\n      ,\n      onEditNode: () => selectedNode && openLargeEditor(selectedNode),\n      onDeleteNode: deleteNode,\n      selectedNode: selectedNode,\n      isRootSelected: isRootSelected,\n      onSave: saveMindMap,\n      onLoad: loadMindMap,\n      loading: loading,\n      message: message,\n      onLogout: handleLogout,\n      userName: (session === null || session === void 0 ? void 0 : (_session$user = session.user) === null || _session$user === void 0 ? void 0 : _session$user.email) || 'User'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 502,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MindMapInstructions, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 518,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MindMapCanvas, {\n      nodes: nodes,\n      connections: connections,\n      draggedNode: draggedNode,\n      selectedNode: selectedNode,\n      translateX: translateX,\n      translateY: translateY,\n      handleMouseDown: handleMouseDown,\n      openNodeEditor: openLargeEditor,\n      canvasWrapperRef: canvasWrapperRef,\n      svgRef: svgRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 520,\n      columnNumber: 7\n    }, this), isLargeEditorOpen && /*#__PURE__*/_jsxDEV(LargeTextEditor, {\n      isOpen: isLargeEditorOpen,\n      initialTitle: largeEditorTitle,\n      initialText: largeEditorText,\n      onSave: saveLargeEditorText,\n      onCancel: closeLargeEditor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 534,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 501,\n    columnNumber: 5\n  }, this);\n};\n_s(MindMap, \"iHAUyGKASbl8mFgHKDuukRlWfi8=\");\n_c = MindMap;\nexport default MindMap;\nvar _c;\n$RefreshReg$(_c, \"MindMap\");","map":{"version":3,"names":["React","useState","useRef","useCallback","useEffect","useMemo","createClient","MindMapCanvas","MindMapToolbar","MindMapInstructions","LargeTextEditor","Auth","jsxDEV","_jsxDEV","supabaseUrl","process","env","REACT_APP_SUPABASE_URL","supabaseAnonKey","REACT_APP_SUPABASE_ANON_KEY","console","error","supabase","API_BASE_URL","REACT_APP_BACKEND_API_URL","MindMap","_s","_nodes$find","_session$user","nodes","setNodes","id","x","y","title","text","isRoot","color","connections","setConnections","draggedNode","setDraggedNode","selectedNode","setSelectedNode","isLargeEditorOpen","setIsLargeEditorOpen","largeEditorNodeId","setLargeEditorNodeId","largeEditorTitle","setLargeEditorTitle","largeEditorText","setLargeEditorText","translateX","setTranslateX","translateY","setTranslateY","isPanning","setIsPanning","panStartRef","startTranslateX","startTranslateY","svgRef","containerRef","canvasWrapperRef","dragDataRef","isDragging","offset","animationFrameRef","colors","session","setSession","mindmapId","setMindmapId","loading","setLoading","message","setMessage","initialLoadAttempted","setInitialLoadAttempted","saveMindMap","access_token","mindMapData","name","nodes_data","connections_data","translate_x","translate_y","response","fetch","method","headers","body","JSON","stringify","ok","errorData","json","parseError","status","errorMessage","Error","result","data","log","loadMindMap","loadedMap","handleAuthEvent","event","currentSession","auth","getSession","then","initialSession","subscription","onAuthStateChange","unsubscribe","handleAuthSuccess","newSession","handleLogout","signOut","handleMouseMove","e","current","cancelAnimationFrame","requestAnimationFrame","_containerRef$current","rect","getBoundingClientRect","newX","clientX","left","newY","clientY","top","prev","map","node","handleMouseDown","nodeId","_containerRef$current2","preventDefault","stopPropagation","currentCanvasWrapper","classList","add","find","n","nodeEl","currentTarget","nodeRect","containerRect","handleMouseUp","remove","handlePanMouseDown","isTargetNode","target","closest","isTargetToolbar","isTargetInstructions","isTargetLargeEditor","button","handlePanMouseMove","dx","dy","container","handleGlobalMove","handleGlobalUp","handlePanDown","document","addEventListener","removeEventListener","closeLargeEditor","saveLargeEditorText","newTitle","newText","trim","openLargeEditor","addNode","parent","angle","Math","random","PI","distance","newNode","Date","now","toString","cos","sin","floor","length","from","to","deleteNode","nodeToDelete","filter","c","isRootSelected","onAuthSuccess","fileName","_jsxFileName","lineNumber","columnNumber","className","ref","children","onAddNode","onEditNode","onDeleteNode","onSave","onLoad","onLogout","userName","user","email","openNodeEditor","isOpen","initialTitle","initialText","onCancel","_c","$RefreshReg$"],"sources":["/Users/jimmyzhou/Desktop/Projects/scripty/frontend/src/pages/mindmap.jsx"],"sourcesContent":["import React, { useState, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { createClient } from '@supabase/supabase-js';\nimport MindMapCanvas from '../components/mindmapcanvas';\nimport MindMapToolbar from '../components/mindmaptoolbar';\nimport MindMapInstructions from '../components/mindmapinstructions';\nimport LargeTextEditor from '../components/mindmaptexteditor';\nimport Auth from '../components/Auth';\n\nimport './mindmap.css';\n\n// --- Supabase Client Initialization ---\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL;\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;\n\n// Log error if Supabase keys are missing in frontend .env\nif (!supabaseUrl || !supabaseAnonKey) {\n  console.error('REACT_APP_SUPABASE_URL or REACT_APP_SUPABASE_ANON_KEY is missing in frontend .env file.');\n  // In a production app, you might want to display a more prominent error to the user\n}\nconst supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// --- Backend API URL ---\nconst API_BASE_URL = process.env.REACT_APP_BACKEND_API_URL;\nif (!API_BASE_URL) {\n  console.error('REACT_APP_BACKEND_API_URL is not defined in frontend .env file. API calls will fail.');\n}\n\n\nconst MindMap = () => {\n  // --- Mind Map State ---\n  const [nodes, setNodes] = useState([\n    { id: '1', x: 400, y: 300, title: 'Central Idea', text: '', isRoot: true, color: '#dc2626' }\n  ]);\n  const [connections, setConnections] = useState([]);\n  const [draggedNode, setDraggedNode] = useState(null);\n  const [selectedNode, setSelectedNode] = useState(null);\n\n  // --- Large Text Editor State ---\n  const [isLargeEditorOpen, setIsLargeEditorOpen] = useState(false);\n  const [largeEditorNodeId, setLargeEditorNodeId] = useState(null);\n  const [largeEditorTitle, setLargeEditorTitle] = useState('');\n  const [largeEditorText, setLargeEditorText] = '';\n\n  // --- Canvas Panning/Transform State ---\n  const [translateX, setTranslateX] = useState(0);\n  const [translateY, setTranslateY] = useState(0);\n  const [isPanning, setIsPanning] = useState(false);\n  const panStartRef = useRef({ x: 0, y: 0, startTranslateX: 0, startTranslateY: 0 });\n\n  // --- Refs for DOM elements ---\n  const svgRef = useRef(null);\n  const containerRef = useRef(null);\n  const canvasWrapperRef = useRef(null);\n\n  // --- Dragging Refs and Animation Frame ---\n  const dragDataRef = useRef({ isDragging: false, offset: { x: 0, y: 0 } });\n  const animationFrameRef = useRef(null);\n\n  // --- Node Colors ---\n  const colors = useMemo(() => [\n    '#EF4444', // Red\n    '#F97316', // Orange\n    '#EAB308', // Yellow\n    '#22C55E', // Green\n    '#3B82F6', // Blue\n    '#A855F7', // Purple\n    '#EC4899', // Pink\n  ], []);\n\n  // --- Authentication and Persistence States ---\n  const [session, setSession] = useState(null);\n  const [mindmapId, setMindmapId] = useState(null); // ID of the currently loaded/saved mind map\n  const [loading, setLoading] = useState(false); // General loading state for API operations\n  const [message, setMessage] = useState(''); // User feedback message\n  const [initialLoadAttempted, setInitialLoadAttempted] = useState(false); // To prevent redundant initial loads\n\n\n  // --- Backend API Save Function ---\n  const saveMindMap = useCallback(async () => {\n    // Prevent saving if not authenticated\n    if (!session || !session.access_token) {\n      setMessage('You must be logged in to save your mind map. Please log in.');\n      return;\n    }\n    // Prevent multiple save calls if one is already in progress\n    if (loading) {\n        setMessage('Save in progress...');\n        return;\n    }\n\n    setLoading(true);\n    setMessage('Saving mind map...');\n\n    const mindMapData = {\n      mindmapId, // Will be null for new maps, ID for existing maps\n      name: 'My Awesome Mind Map', // You might want to make this dynamic later\n      nodes_data: nodes,\n      connections_data: connections,\n      translate_x: translateX,\n      translate_y: translateY,\n    };\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/mindmaps`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session.access_token}`, // Send JWT for authentication\n        },\n        body: JSON.stringify(mindMapData),\n      });\n\n      // Check for non-OK response (e.g., 4xx, 5xx status codes)\n      if (!response.ok) {\n        let errorData;\n        try {\n          errorData = await response.json(); // Try to parse error message from backend\n        } catch (parseError) {\n          console.error('Failed to parse error response during save:', parseError);\n          setMessage(`Error saving mind map: Server responded with status ${response.status} but no valid JSON error message.`);\n          return;\n        }\n        const errorMessage = errorData.message || errorData.error || `Unknown error (Status: ${response.status})`;\n        throw new Error(errorMessage);\n      }\n\n      const result = await response.json();\n      setMindmapId(result.data.id); // Update mindmapId with the ID of the saved map\n      setMessage('Mind map saved successfully!');\n      console.log('Mind map saved:', result.data);\n\n    } catch (error) {\n      setMessage(`Error saving mind map: ${error.message}.`);\n      console.error('Error saving mind map:', error);\n    } finally {\n      setLoading(false); // Reset loading state\n    }\n  }, [session, nodes, connections, translateX, translateY, mindmapId, loading]);\n\n\n  // --- Backend API Load Function ---\n  const loadMindMap = useCallback(async () => {\n    // Prevent loading if not authenticated\n    if (!session || !session.access_token) {\n      setMessage('Please log in to load your mind map.');\n      // Optionally reset to default if not logged in to avoid showing stale data\n      setNodes([{ id: '1', x: 400, y: 300, title: 'Central Idea', text: '', isRoot: true, color: '#dc2626' }]);\n      setConnections([]);\n      setTranslateX(0);\n      setTranslateY(0);\n      setMindmapId(null);\n      return;\n    }\n    // Prevent multiple load calls if one is already in progress\n    if (loading) {\n        setMessage('Load in progress...');\n        return;\n    }\n\n    setLoading(true);\n    setMessage('Loading mind map...');\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/mindmaps`, {\n        headers: {\n          'Authorization': `Bearer ${session.access_token}`, // Send JWT for authentication\n        },\n      });\n\n      // Handle non-OK responses\n      if (!response.ok) {\n        if (response.status === 404) {\n          // Specific handling for \"no mind map found\"\n          setMessage('No mind map found for this user. You can start creating one now!');\n          // Initialize with a default central idea for a new user\n          setNodes([{ id: '1', x: 400, y: 300, title: 'Central Idea', text: '', isRoot: true, color: '#dc2626' }]);\n          setConnections([]);\n          setTranslateX(0);\n          setTranslateY(0);\n          setMindmapId(null); // Ensure mindmapId is null for a new, unsaved map\n          return; // Exit as this is a handled scenario\n        }\n\n        let errorData;\n        try {\n          errorData = await response.json(); // Try to parse other error messages\n        } catch (parseError) {\n          console.error('Failed to parse error response during load:', parseError);\n          setMessage(`Error loading mind map: Server responded with status ${response.status} but no valid JSON error message.`);\n          return;\n        }\n        const errorMessage = errorData.message || errorData.error || `Unknown error (Status: ${response.status})`;\n        throw new Error(errorMessage);\n      }\n\n      const result = await response.json();\n      const loadedMap = result.data;\n      setNodes(loadedMap.nodes_data);\n      setConnections(loadedMap.connections_data);\n      setTranslateX(loadedMap.translate_x);\n      setTranslateY(loadedMap.translate_y);\n      setMindmapId(loadedMap.id);\n      setMessage('Mind map loaded successfully!');\n      console.log('Mind map loaded:', loadedMap);\n\n    } catch (error) {\n      setMessage(`Error loading mind map: ${error.message}. Please try again or re-authenticate.`);\n      console.error('Error loading mind map:', error);\n    } finally {\n      setLoading(false); // Reset loading state\n    }\n  }, [session, loading]); // Dependencies: session (for token), loading (to prevent re-entry)\n\n\n  // --- Supabase Authentication State Management ---\n  useEffect(() => {\n    // This function handles both initial session retrieval and subsequent auth state changes\n    const handleAuthEvent = async (event, currentSession) => {\n      console.log('Auth Event:', event, 'Session:', currentSession); // Detailed logging for debugging\n      setSession(currentSession);\n\n      if (currentSession) {\n        // Only trigger loadMindMap if user just signed in, token was refreshed, or if it's the very first load attempt\n        if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED' || !initialLoadAttempted) {\n          setMessage('Logged in. Loading your mind map...');\n          await loadMindMap(); // Wait for load to complete before marking as attempted\n          setInitialLoadAttempted(true); // Mark that an initial load has been attempted\n        } else {\n            // If already authenticated and not an event that requires a re-load, just update message\n            setMessage('You are logged in.');\n        }\n      } else {\n        // User is logged out (either SIGNED_OUT or no session initially)\n        setMessage('Logged out. Please log in or sign up.');\n        // Reset mind map state to default when user logs out\n        setNodes([{ id: '1', x: 400, y: 300, title: 'Central Idea', text: '', isRoot: true, color: '#dc2626' }]);\n        setConnections([]);\n        setTranslateX(0);\n        setTranslateY(0);\n        setMindmapId(null);\n        setInitialLoadAttempted(false); // Reset this for the next login attempt\n      }\n    };\n\n    // 1. Get the initial session when the component mounts\n    supabase.auth.getSession().then(({ data: { session: initialSession } }) => {\n      handleAuthEvent('INITIAL_LOAD', initialSession); // Use a custom event type for clarity\n    });\n\n    // 2. Subscribe to real-time authentication state changes\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(handleAuthEvent);\n\n    // Clean up the subscription when the component unmounts\n    return () => subscription.unsubscribe();\n  }, [loadMindMap, initialLoadAttempted]); // Dependencies: loadMindMap and initialLoadAttempted\n\n\n  // Callback from Auth component after successful login/signup\n  const handleAuthSuccess = useCallback(async (newSession) => {\n    setMessage('Authentication successful. Loading your mind map...');\n    setSession(newSession); // Update session immediately\n    await loadMindMap(); // Load map immediately after successful auth\n    setInitialLoadAttempted(true); // Mark as attempted\n  }, [loadMindMap]);\n\n  // Logout function\n  const handleLogout = useCallback(async () => {\n    setLoading(true);\n    setMessage('Logging out...');\n    try {\n      const { error } = await supabase.auth.signOut();\n      if (error) throw error;\n      setMessage('Logged out successfully.');\n      // The `onAuthStateChange` listener will handle the state reset after signOut\n    } catch (error) {\n      setMessage(`Logout error: ${error.message}`);\n      console.error('Logout error:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n\n  // --- Mouse Handlers for Node Dragging ---\n  const handleMouseMove = useCallback((e) => {\n    if (!dragDataRef.current.isDragging || !draggedNode) return;\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    animationFrameRef.current = requestAnimationFrame(() => {\n      const rect = containerRef.current?.getBoundingClientRect();\n      if (!rect) return;\n      // Calculate new position relative to the container and current pan\n      const newX = (e.clientX - rect.left - dragDataRef.current.offset.x - translateX);\n      const newY = (e.clientY - rect.top - dragDataRef.current.offset.y - translateY);\n      setNodes(prev => prev.map(node =>\n        node.id === draggedNode\n          ? { ...node, x: newX, y: newY }\n          : node\n      ));\n    });\n  }, [draggedNode, translateX, translateY]);\n\n  const handleMouseDown = useCallback((e, nodeId) => {\n    e.preventDefault();\n    e.stopPropagation(); // Prevent canvas panning from starting when clicking a node\n    if (selectedNode !== nodeId) {\n      setSelectedNode(nodeId);\n    }\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.add('no-transition'); // Disable transition during drag\n    }\n    const node = nodes.find(n => n.id === nodeId);\n    if (!node) return;\n    const nodeEl = e.currentTarget; // Get the DOM element for the node\n    if (!nodeEl) return;\n    const nodeRect = nodeEl.getBoundingClientRect();\n    const containerRect = containerRef.current?.getBoundingClientRect();\n    if (!containerRect) return;\n\n    // Calculate offset from mouse click to node's top-left corner\n    dragDataRef.current = {\n      isDragging: true,\n      offset: {\n        x: e.clientX - nodeRect.left,\n        y: e.clientY - nodeRect.top\n      }\n    };\n    setDraggedNode(nodeId);\n  }, [nodes, selectedNode]);\n\n  const handleMouseUp = useCallback(() => {\n    dragDataRef.current.isDragging = false;\n    setDraggedNode(null);\n    setIsPanning(false); // Ensure panning state is reset\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.remove('no-transition'); // Re-enable transition after drag\n    }\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, []);\n\n  // --- Mouse Handlers for Panning ---\n  const handlePanMouseDown = useCallback((e) => {\n    // Only pan if a node, toolbar, instructions, or editor isn't clicked AND it's the left mouse button\n    const isTargetNode = e.target.closest('.mindmap-node');\n    const isTargetToolbar = e.target.closest('.mindmap-toolbar');\n    const isTargetInstructions = e.target.closest('.mindmap-instructions');\n    const isTargetLargeEditor = e.target.closest('.large-text-editor-overlay');\n    if (isTargetNode || isTargetToolbar || isTargetInstructions || isTargetLargeEditor || e.button !== 0) {\n        return;\n    }\n    setIsPanning(true);\n    panStartRef.current = {\n      x: e.clientX,\n      y: e.clientY,\n      startTranslateX: translateX,\n      startTranslateY: translateY\n    };\n    const currentCanvasWrapper = canvasWrapperRef.current;\n    if (currentCanvasWrapper) {\n      currentCanvasWrapper.classList.add('no-transition');\n    }\n    setSelectedNode(null); // Deselect any node when panning starts\n    e.preventDefault(); // Prevent default browser drag behavior (e.g., image dragging)\n  }, [translateX, translateY]);\n\n  const handlePanMouseMove = useCallback((e) => {\n    if (!isPanning) return;\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    animationFrameRef.current = requestAnimationFrame(() => {\n      const dx = e.clientX - panStartRef.current.x;\n      const dy = e.clientY - panStartRef.current.y;\n      setTranslateX(panStartRef.current.startTranslateX + dx);\n      setTranslateY(panStartRef.current.startTranslateY + dy);\n    });\n  }, [isPanning]);\n\n  // Global mouse event listeners for dragging and panning\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return; // Ensure container ref is available\n\n    const handleGlobalMove = (e) => {\n      if (draggedNode) {\n        handleMouseMove(e);\n      } else if (isPanning) {\n        handlePanMouseMove(e);\n      }\n    };\n\n    const handleGlobalUp = () => handleMouseUp(); // This function resets all dragging/panning states\n\n    const handlePanDown = (e) => handlePanMouseDown(e); // Listener for canvas pan initiation\n\n    // Attach listeners to document for robust dragging/panning even if mouse leaves container\n    document.addEventListener('mouseup', handleGlobalUp);\n    document.addEventListener('mouseleave', handleGlobalUp); // Important for when mouse leaves browser window\n    container.addEventListener('mousemove', handleGlobalMove); // Listen on container for mouse movement\n    container.addEventListener('mousedown', handlePanDown); // Listen on container for pan start\n\n    // Cleanup function\n    return () => {\n      document.removeEventListener('mouseup', handleGlobalUp);\n      document.removeEventListener('mouseleave', handleGlobalUp);\n      container.removeEventListener('mousemove', handleGlobalMove);\n      container.removeEventListener('mousedown', handlePanDown);\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      // Ensure no-transition class is removed on unmount too\n      const currentCanvasWrapper = canvasWrapperRef.current;\n      if (currentCanvasWrapper) {\n        currentCanvasWrapper.classList.remove('no-transition');\n      }\n    };\n  }, [handleMouseMove, handleMouseUp, handlePanMouseDown, handlePanMouseMove, draggedNode, isPanning]);\n\n\n  // --- Large Text Editor Functions ---\n  const closeLargeEditor = useCallback(() => {\n    setIsLargeEditorOpen(false);\n    setLargeEditorNodeId(null);\n    setLargeEditorTitle('');\n    setLargeEditorText('');\n  }, []);\n\n  const saveLargeEditorText = useCallback((newTitle, newText) => {\n    if (!largeEditorNodeId) return;\n    setNodes(prev =>\n      prev.map(node => (\n        node.id === largeEditorNodeId\n          ? { ...node, title: newTitle.trim() || 'New Idea', text: newText.trim() || '' }\n          : node\n      ))\n    );\n    closeLargeEditor();\n  }, [largeEditorNodeId, closeLargeEditor]);\n\n  const openLargeEditor = useCallback((nodeId) => {\n    const node = nodes.find(n => n.id === nodeId);\n    if (node) {\n      setIsLargeEditorOpen(true);\n      setLargeEditorNodeId(nodeId);\n      setLargeEditorTitle(node.title || '');\n      setLargeEditorText(node.text || '');\n    }\n  }, [nodes]);\n\n  // --- Mind Map Node Operations ---\n  const addNode = useCallback(() => {\n    const parent = selectedNode ? nodes.find(n => n.id === selectedNode) : nodes.find(n => n.isRoot);\n    if (!parent) {\n      setMessage('Cannot add node: No root node found or selected node does not exist.');\n      return;\n    }\n    const angle = Math.random() * 2 * Math.PI; // Random angle for new node placement\n    const distance = 150; // Distance from parent\n    const newNode = {\n      id: Date.now().toString(), // Unique ID for new node\n      x: parent.x + Math.cos(angle) * distance,\n      y: parent.y + Math.sin(angle) * distance,\n      title: 'New Idea',\n      text: '',\n      color: colors[Math.floor(Math.random() * colors.length)] // Random color\n    };\n    setNodes(prev => [...prev, newNode]);\n    setConnections(prev => [...prev, { from: parent.id, to: newNode.id }]);\n    setSelectedNode(newNode.id); // Select the newly created node\n    openLargeEditor(newNode.id); // Open editor for new node\n  }, [nodes, colors, selectedNode, openLargeEditor]);\n\n  const deleteNode = useCallback(() => {\n    const nodeToDelete = nodes.find(n => n.id === selectedNode);\n    if (!nodeToDelete || nodeToDelete.isRoot) {\n      setMessage('Cannot delete root node or no node selected.');\n      return;\n    }\n    setNodes(prev => prev.filter(n => n.id !== selectedNode)); // Remove node\n    setConnections(prev => prev.filter(c => c.from !== selectedNode && c.to !== selectedNode)); // Remove related connections\n    setSelectedNode(null); // Deselect after deleting\n  }, [nodes, selectedNode]);\n\n  // Helper to check if the selected node is the root\n  const isRootSelected = selectedNode ? nodes.find(n => n.id === selectedNode)?.isRoot : false;\n\n  // --- Conditional Rendering for Authentication ---\n  // If no session, render the Auth component\n  if (!session) {\n    return <Auth onAuthSuccess={handleAuthSuccess} />;\n  }\n\n  // --- Main Mind Map UI Rendering ---\n  return (\n    <div className=\"mindmap-container\" ref={containerRef}>\n      <MindMapToolbar\n        onAddNode={addNode}\n        // The comment explaining the onEditNode prop should be a regular JavaScript comment\n        // above the prop or within the function if it's complex, not a separate JSX comment.\n        onEditNode={() => selectedNode && openLargeEditor(selectedNode)}\n        onDeleteNode={deleteNode}\n        selectedNode={selectedNode}\n        isRootSelected={isRootSelected}\n        onSave={saveMindMap}\n        onLoad={loadMindMap}\n        loading={loading}\n        message={message}\n        onLogout={handleLogout}\n        userName={session?.user?.email || 'User'}\n      />\n\n      <MindMapInstructions />\n\n      <MindMapCanvas\n        nodes={nodes}\n        connections={connections}\n        draggedNode={draggedNode}\n        selectedNode={selectedNode}\n        translateX={translateX}\n        translateY={translateY}\n        handleMouseDown={handleMouseDown}\n        openNodeEditor={openLargeEditor}\n        canvasWrapperRef={canvasWrapperRef}\n        svgRef={svgRef}\n      />\n\n      {isLargeEditorOpen && (\n        <LargeTextEditor\n          isOpen={isLargeEditorOpen}\n          initialTitle={largeEditorTitle}\n          initialText={largeEditorText}\n          onSave={saveLargeEditorText}\n          onCancel={closeLargeEditor}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default MindMap;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}